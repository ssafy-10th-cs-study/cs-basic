# 클래스, 객체, 인스턴스

\*\* 아래 셋의 차이점 확실하게 알아둘 것

## 클래스

객체를 만들어 내기 위한 틀이며 만들어 낼 객체의 속성과 메서드의 집합을 담아 놓은 것

## 객체

객체란 클래스로부터 만들어지는 실체, 클래스로 선언된 변수를 객체라고 함

## 인스턴스

객체가 메모리에 할당이 된 상태이며 런타임에 구동되는 객체를 의미. 객체와 같은 의미로 쓰이기도 함

(다른 의미로 AWS 클라우드의 가상 서버 이름이기도 함)

```java
public static void main(String[] args) {
	Person a = new Person(); // 객체 => 인스턴스

	// 인스턴스화 될 때 힙에 올라감
	Person b; // 객체
	b = new Person("", 1, 1000); // 인스턴스
}
```

# static

## static 키워드

클래스의 인스턴스가 아닌 **클래스에 속하며** 클래스의 변수, 메서드 등을 공유하는데 사용

해당 클래스로 만들어지는 객체 사이에서 중복되는 메서드, 속성을 효율적으로 정의할 때 사용

> 예를 들어 Person 클래스에서 객체를 만들 때 각자 talk라는 메서드를 만드는 것보다 Person.talk()를 실행함으로써 Person 끼리 대화하는 메서드라는 명시성을 지니게 됨 ⇒ 메모리의 효율성이 증가함

## 단점

선언하자마자 메모리에 올라감

만약 인스턴스를 생성하지 않을 것이라면 메모리 낭비가 될 수 있음

\*\* Java 기준

static으로 생성하지 않으면, 인스턴스가 객체화 될 때 heap 영역에 올라감.

해당 heap 영역은 Garbage Collector가 관리하는데, static으로 명시한 것은 회수가 되지 않아 **메모리 낭비**가 될 수 있다.

# 오버로딩과 오버라이딩

## 오버로딩

이름이 같아도 **매개변수 개수, 타입, 순서를 다르게 해서 같은 이름으로도 여러 개의 함수를 정의**할 수 있는 것

프로그램의 유연성을 높이고 결과적으로 코드를 깔끔하게 하는 효과가 있으며 같은 클래스 내에서 사용

```java
class Calculator {
	void multiply(int a, int b) {}
	void multiply(int a, int b, int c) {}
	void multiply(double a, double b) {}
}
```

## 오버라이딩

**상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의** 하는 것을 의미

상속 관계 클래스에서 사용되며 static, final로 선언한 메서드는 오버라이딩이 불가능

**주로 annotation으로 명시**

```java
class Animal {
	void eat() {
		sout("먹습니다");
	}
}

class Person extends Animal {
	@override // annotation
	void eat() {
		sout("사람처럼 먹습니다");
	}
}
```

# 추상화

복잡한 데이터, 구조, 시스템 등으로부터 핵심만을 가려내 **덜 자세하게 만드는 것** 또는 세부사항, 절차 등을 감추고 인터페이스 등을 만드는 것으로 **복잡도를 낮추는 방법**

## 데이터 추상화

어떠한 데이터들의 공통점을 모으고 차이점을 버림

ex) 고양이, 강아지, 원숭이 등의 객체들의 공통적인 특징을 묶어 동물이라는 카테고리로 카테고리화 시킴

## 프로세스 추상화

어떠한 내부 프로세스를 숨기는 것

ex) 데이터베이스가 어떻게 데이터를 저장하는지는 모르지만, 단순하게 insert, upsert 등의 쿼리로 데이터를 저장할 수 있음 ⇒ 함수를 만들었을 때 사용자는 그 함수를 사용하는 방법만 알면 되고, 그 함수의 동작 방식은 어떤지 알지 못하고 알 필요도 없는 것
