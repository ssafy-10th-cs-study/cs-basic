## 로그인 - 세션 기반 인증 방식

로그인은 **세션 기반 인증 방식** 또는 **토큰 기반 인증 방식**으로 구현됨

HTTP의 특징 중 하나는 **상태 없음**이라는 것(stateless)

즉 HTTP 요청을 통해 데이터를 주고 받을 때 요청이 끝나면 요청한 사용자의 정보 등을 유지하지 않는 특징

- **세션** 서버와 클라이언트의 연결이 활성화된 상태

- **세션 ID** 웹 서버 또는 DB에 저장되는 클라이언트에 대한 유니크한 ID

### 세션기반 로그인 프로세스

로그인 상태를 어떻게 유지하는가?

1. 처음 로그인하면 세션 ID가 생성되고 서버에서 세션 ID를 쿠키로 설정해서 클라이언트에 전달

2. 클라이언트가 서버에 요청을 보낼 때 해당 세션 ID를 쿠키로 담아서 전에 로그인했던 아이디인지 확인

3. 로그인을 유지

서버가 쿠키를 만들면서 이것이 DB나 WAS에 저장됨

보통 세션을 다루는 라이브러리는 세션 ID를 생성했을 때 쿠키에 해당 값이 설정되는 것이 일반적(로컬 스토리지 또는 세션 스토리지에 담을 수도 있음)

### 단점

1. 사용자의 상태에 관한 데이터를 웹 서버(WAS)에 저장했을 때 로그인 중인 유저의 수가 늘어난다면 서버의 메모리 과부화가 일어날 수 있음

2. DB 중 RDBMS에 저장한다면 직렬화 및 역직렬화에 관한 오버헤드가 발생

<br>

## 로그인 - 토큰 기반 인증 방식

### 토큰 기반 인증 방식

토큰 기반 인증 방식은 state를 모두 토큰 자체만으로 처리하며 토큰을 처리하는 한 서버를 두고 다른 컨텐츠를 제공하는 서버는 모두 stateless하게 만들자는 이론이 담긴 방식

**토큰을 관리하는 서버를 따로 두어야 하는 이유**

→ 여러 개의 서버를 운용할 때 *토큰 기반 인증 + 어떤 도메인을 처리하는 서버*로 구축할 경우 이 도메인에서 에러가 발생되면 인증에 관한 기능이 마비되고 다른 도메인들의 기능이 연쇄적으로 마비될 수 있기 때문

토큰은 주로 JWT 토큰이 활용됨

1. 인증 로직 → JWT 토큰 생성(access 토큰, refresh 토큰)

2. 사용자가 이후에 access 토큰을 HTTP Header-Authorization 또는 HTTP Header-Cookie에 담아 인증이 필요한 서버에 요청해 원하는 컨텐츠를 가져옴

로그인을 하게 되면 access 토큰과 refresh 토큰 두 개를 얻음 → access 토큰이 만료되거나 사용자가 새로고침 할 때 refresh 토큰 기반으로 새로운 access 토큰을 얻음

access 토큰은 인증에 필요하고 refresh 토큰은 access 토큰을 갱신할 때 필요함(해킹 방지)

이를 통해 access 토큰이 만료됐을 때마다 인증에 관한 비용이 줄어들게 됨

access 토큰의 수명은 짧게 하고 refresh 토큰의 수명은 길게 함

### JWT

JSON Web Token을 의미하며 Header, Payload, Signature로 이루어져 있으며 JSON 객체로 인코딩되고 메시지 인증, 암호화에 사용

**Header**

토큰 유형과 서명 알고리즘, base64URI로 인코딩됨

**Payload**

데이터, 토큰 발급자, 토큰 유효기간, base64URI로 인코딩됨

**Signature**

(인코딩된 header + payload) + 비밀키를 기반으로 헤더에 명시된 알고리즘으로 다시 생성한 서명값

### 장점

1. 사용자 인증에 필요한 모든 정보를 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요 없음

2. 다른 유형의 토큰과 비교했을 때 경량화됨 → SAML(Security Assertion Markup Language Tokens)이라는 토큰이 있지만 이에 비해 훨씬 경량화

3. 디코딩했을 때 JSON이 나오기 때문에 JSON을 기반으로 쉽게 직렬화, 역직렬화가 가능

### 단점

1. 토큰이 비대해질 경우(정보가 많아져서 길이가 길어짐) 당연히 서버 과부화에 영향을 줄 수 있음

2. 토큰을 탈취당할 경우 디코딩했을 때 데이터를 볼 수 있음

### 주의할 점

- `Bearer <token>`으로 Bearer을 앞에 둬서 토큰 기반 인증 방식이라는 것을 알려주어야 함

- `https`를 사용

- 쿠키에 저장한다면 `sameSite: 'Strict'`을 써야 함

- 수명이 짧은 access 토큰을 발급

- url에 토큰을 전달하지 말아야 함

<br>

## HTTP 상태 코드(Status Code)

### 1xx (정보)

서버가 요청을 잘 받았으며 해당 프로세스를 계속 이어가며 처리하는 것을 의미

- `100` 계속함을 의미

### 2xx (성공)

서버가 요청을 잘 받았고 이를 기반으로 클라이언트에게 성공적으로 데이터를 보낸 것을 의미

- `200 OK` 요청이 성공적으로 됨

- `201 Created` 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성

### 3xx (리다이렉션)

서버가 클라이언트의 요청에 대한 완료를 위해 추가 작업 조치가 필요

- `301 Moved Permanently` 요청한 리소스의 URI가 변경되었음을 의미하며 변경된 새로운 URI을 301 상태코드와 함께 주어야 함

### 4xx (클라이언트 오류)

클라이언트가 요청한 페이지를 제공할 수 없거나 클라이언트의 요청이 잘못되어 결과적으로 요청을 처리할 수 없음

- `400 Bad Request` 서버가 클라이언트 요청을 이해할 수 없음을 의미

- `401 Unauthorized` 클라이언트의 인증이 되지 않음을 의미

- `404 Not Found` 요청받은 컨텐츠를 찾을 수 없다는 것을 의미

### 5xx (서버 오류)

서버가 클라이언트의 요청을 처리하지 못하는 상태

- `500 Internal Server Error` 서버에 오류가 있음을 의미

- `502 Bad Gateway` 게이트웨이 또는 프록시 서버가 오류가 생겼음을 의미

- `504 Gateway Timeout` 게이트웨이 또는 프록시 서버가 정해진 Timeout 시간동안 클라이언트의 요청을 처리하지 못함을 의미

<br>

## HTTP 메서드 #1. GET과 POST의 차이

### GET : 데이터를 읽다

- url 기반으로 데이터를 요구하는 방법

- url 기반이기 때문에 길이 제한(2000자 미만)이 있음

- 성공시 HTTP 상태코드 200을 반환

- 캐싱이 가능

- url을 기반으로 요청하기 때문에 해당 요청의 파라미터가 브라우저 기록에 남음

- url을 기반으로 요청하기 때문에 요청할 때 ASCII문자열만을 보낼 수 있음

- 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용하지 않음

### POST : 데이터를 생성하다

- url이 아닌 HTTP message body를 통해 데이터를 전달

- HTTP message body를 통해 전달되기 때문에 길이 제한이 없음

- 성공적으로 데이터를 생성할 경우 HTTP 상태코드 201을 반환(생성한 경우 201, 생성하지 않은 경우 200을 반환하기도 함)

- 캐싱이 불가능

- url을 기반으로 요청하지 않기 때문에 해당 요청의 파라미터가 브라우저 기록에 남지 않음

- HTTP message body로 요청하기 때문에 ASCII문자열 뿐만 아니라 모든 유형의 데이터를 기반으로 요청할 수 있음

- 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용

어차피 패킷 분석을 하면 body에 있는 내용도 탐색할 수 있지만 1차적으로 보호하는 효과

<br>

## HTTP 메서드 #2. PUT과 PATCH의 차이

둘 다 데이터를 수정할 때 쓰는 메서드

### PUT : 업데이트하는 데이터의 전체를 보내다

요청을 보낼 때 해당 데이터 전체를 보내야 하고 전체 데이터의 교체를 의미

또한 만약 해당 데이터가 없다면 새로 생성하고 해당 데이터가 있다면 요청할 때 보낸 데이터와 교체 진행

### PATCH : 업데이트하는 데이터의 일부를 보내다

요청을 보낼 때 수정하는 일부분만 보내면 되고 일부분의 교체를 의미

`{"a" : 1, "b" : 2}`에서 b를 3으로 바꿀 때

**PUT** → `{"a" : 1, "b" : 3}`으로 전체 데이터 전부

**PATCH** → `{"b" : 3}`으로 부분적으로 보냄

<br>

## 네트워크를 이루는 장치의 이해

네트워크 기기는 계층별로 나눌 수 있으며 상위 계층을 처리하는 기기는 하위계층을 처리할 수 있지만 그 반대는 불가능

### 레이어별 프로토콜, PDU 정리

![image](https://github.com/annyoon/movie-movie-react/assets/79207743/9f9164c7-d258-4534-8a53-4c148cfda5d3)

### 레이어별 네트워크 장치

- **애플리케이션 계층** L7 스위치

- **전송 계층** L4 스위치

- **인터넷 계층(네트워크 계층)** 라우터, L3 스위치

- **데이터 링크 계층** L2 스위치, 브리지

- **물리 계층** NIC, 리피터, AP

<br>

## 네트워크를 이루는 장치 #1. 애플리케이션 계층

### L7 스위치

로드밸런서라고도 하며 서버의 부하를 분산하고 서버 이중화, 보안에 강점이 있는 장치

IP, Port뿐만 아니라 url, 헤더, 쿠키 등을 기반으로 트래픽을 분산

헬스 체크(주기적인 서버 상태 점검)를 통해 장애가 발생한 서버를 확인하고 해당 서버로 트래픽을 보내지 못하게 하는 역할

<br>

## 네트워크를 이루는 장치 #2. 전송 계층

### L4 스위치

패킷의 IP 주소와 Port 번호를 참고해서 적절히 트래픽 분산(로드밸런서의 특징)을 할 수 있음

전송 계층의 TCP, UDP 등의 헤더를 기반으로 우선순위를 판단해서 분산이 가능

L7 스위치와 똑같이 헬스 체크가 가능

<br>

## 네트워크를 이루는 장치 #3. 인터넷 계층

### 라우터

라우팅은 하나 이상의 네트워크에서 경로를 선택하는 프로세스를 말하는데 라우팅을 하는 장비

다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고받을 때 **패킷소모 최소화**와 **경로 최적화**를 하는 장비

### L3 스위치

L2 스위치의 기능 + 라우팅을 하는 장비

라우팅 테이블을 참조해서 IP 패킷에 IP 주소를 담아 보냄

<br>

## 네트워크를 이루는 장치 #4. 데이터 링크 계층

링크 계층을 쪼개서 데이터 링크 계층과 물리 계층으로 나눌 수 있음

- **데이터 링크 계층** 이더넷 프레임을 통해 에러 확인, 흐름 제어, 접근 제어를 담당하는 계층

- **물리 계층** 무선 LAN과 유선 LAN을 통해 0과 1로 이루어진 데이터를 보내는 계층

### L2 스위치

장치들의 MAC 주소를 MAC 주소 테이블을 통해 관리하며 인터넷 계층에서 받은 패킷을 기반으로 이더넷 프레임을 만들어 목적지 MAC주소로 패킷을 보내주는 역할

### 브리지

두 개의 근거리 통신망(LAN)을 상호 접속할 수 있도록 하는 통신망 연결 장치

통신망의 범위를 확장하고 서로 다른 LAN을 기반으로 하나의 통신망을 구축할 때 쓰임

<br>

## 네트워크를 이루는 장치 #5. 물리 계층

### NIC

LAN 카드라고 하는 네트워크 인터페이스 카드(NIC, Network Interface Card)

네트워크에 연결하기 위해 PC에 설치된 회로기판을 말하며 이 장치에는 PC 고유의 식별 번호인 MAC 주소가 있음

### 리피터

들어오는 약해진 신호를 증폭하여 다른 쪽으로 전달하는 장치

### AP(Access Point)

패킷을 복사하는 장치

AP에 유선 LAN을 연결한 후 무선 LAN 기술을 기반으로 무선 네트워크망을 구축
