# 운영체제와 컴퓨터 시스템의 구조

운영체제(Operating Systems, OS)란 유저가 컴퓨터를 편하게 사용할 수 있게 모든 하드웨어 자원을 관리해주는 프로그램

## 운영체제의 종류

운영체제는 앞단에 어떤 인터페이스를 두느냐에 따라 GUI와 CUI로 나눌 수 있음

### GUI(Graphical User Interface)

그래픽을 사용하여 컴퓨터와 상호작용하는 인터페이스

windowOS, macOS가 대표적

### CUI(Character User Interface)

사용자가 키보드만을 사용하여 문자를 기반으로 컴퓨터와 상호작용하는 인터페이스

MS-DOS가 대표적(1994년 단종됨)

chatGPT도 CUI라고 할 수 있음

## 운영체제의 역할

운영체제의 커널이 담당

- CPU 스케줄링과 프로세스 상태관리

- 메모리 관리

- 디스크 파일 관리

- I/O 디바이스 관리

## 운영체제의 구조

- 인터페이스(GUI 또는 CUI)

- 시스템콜(System Call)

- 커널(I/O 드라이버, 파일 시스템 등)

## 컴퓨터 시스템의 구조

- CPU: 인터럽트에 의해 메모리에 존재하는 명령어를 해석해서 실행

- DMA 컨트롤러: CPU의 일을 보조

- 메모리: 전자회로에서 데이터, 상태 등을 기록하는 장치

- 타이머: 특정 프로그램에서 시간을 다는 역할

- 디바이스 컨트롤러: IO 디바이스들의 작은 CPU

- 로컬버퍼: 디바이스에 달려있는 작은 메모리

## CPU

산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 장치

인터럽트에 의해 메모리에 존재하는 명령어를 해석해서 실행

### 산술논리연산장치(Arithmetic and Logical Unit, ALU)

덧셈, 뺄셈, 곱셈, 나눗셈 등 산술연산과 논리연산을 하는 회로장치

### 제어장치(Control Unit, CU)

프로세스의 조작을 지시하며 명령어들을 읽고 해석하며 데이터 처리를 위한 순서 결정

### 레지스터

CPU 안에 있는 매우 빠른 임시 기억 장치

<br>

# 인터럽트(Interrupt)

어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것

0으로 숫자를 나누는 산술 연산 오류, 프로세스 오류 등으로 발생

오류뿐만 아니라 키보드, 마우스 등 IO 디바이스를 사용할 떄의 인터럽트, 우선순위가 높은 프로세스의 발생 등으로 인터럽트 발생

## 실행 과정

1. CPU는 메모리에 있는 명령어를 순차적으로 실행

2. 인터럽트가 발생되면 점프해서 인터럽트 핸들러 함수가 모여있는 인터럽트 벡터로 감

3. 인터럽트 핸들러 함수(인터럽트 서비스 루틴, ISR)가 실행되며 특정 명령어를 실행

4. 이후 인터럽트가 종료되면 다시 순차적으로 명령어 실행

## 인터럽트의 종류

### 하드웨어 인터럽트

IO 디바이스 등 하드웨어에서 발생하는 인터럽트

예를 들어 마우스를 기반으로 버튼을 클릭할 때, 디스크에서 파일 읽기, 쓰기 작업이 완료되었을 때 발동

### 소프트웨어 인터럽트

트랩(Trap)이라고도 함

프로세스 오류, 프로세스 종료, 시작 등을 기반으로 프로세스에서 발생하는 인터럽트

하드웨어 인터럽트보다 우선순위가 높은 인터럽트

<br>

# 시스템콜과 modebit

## 시스템콜

시스템콜이란 운영체제가 커널에 접근하기 위한 인터페이스

유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 이를 거쳐서 호출하도록 설계

프로세스 관리(생성, 삭제 등), 파일관리, 디바이스 관리, 시간 및 날짜 관련 시스템, 프로세스 간 통신 때 이를 통해 커널함수를 호출

## 시스템 콜의 과정

만약 유저 프로그램이 I/O 요청을 위한 트랩을 발동했다고 하면 다음과 같은 과정이
발생

1. 유저 프로그램이 I/O 요청 트랩 발동

2. 올바른 I/O 요청인지 확인

3. 유저 모드가 시스템콜을 통해 커널모드로 변환

4. 이후 커널함수를 실행

## 커널함수

커널안에 있는 여러개의 함수(Native Function)

### 커널

운영체제의 핵심 부분이자 시스템콜을 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할

### 유저 모드

유저가 접근할 수 있는 영역을 제한적으로 두며 컴퓨터 자원에 함부로 침범하지 못하는 모드

### 커널 모드

모든 컴퓨터 자원에 접근할 수 있는 모드

### modebit

시스템콜이 작동될 때 modebit을 기반으로 유저 모드와 커널 모드를 구분

modebit은 1 또는 0의 값을 가지는 플래그 변수이며 1은 유저 모드, 0은 커널 모드를 가리킴

## 시스템 콜의 장점

유저 프로그램은 시스템콜을 기반으로 커널과 분리

즉, 유저 프로그램은 복잡한 파일 시스템과 프로세스 생성 등에 대한 내부 동작을 신경 쓸 필요가 없고 또한 운영체제의 관리하에 프로그램이 운영되므로 시스템의 안정성과 보안이 강화됨

<br>

# 메모리계층

메모리 계층(Memory Hierarchy)은 레지스터, 캐시, 주기억장치, 보조기억장치로 구성됨

- 레지스터: CPU 내의 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음

- 캐시: CPU내의 L1, L2 캐시를 지칭하며 휘발성, 속도 빠름, 기억 용량이 적음

- 주기억장치: RAM을 가리키며 휘발성, 속도 보통, 기억 용량이 보통

- 보조기억장치: HDD, SSD를 일컬으며 비휘발성, 속도 낮음, 기억 용량이 많음

## 계층이 존재하는 이유

### 더 빠른 접근과 처리속도가 증가

보통 많이 쓰는 것을 다시 많이 쓰기 때문에 특정 데이터에 많이 접근하게
되는데 좀 더 작은 캐시 메모리에 해당 데이터가 있다면 더 빠르게 해당 데이터에 접근이 가능 → 처리속도 증가

### 비용의 효율성

캐시 메모리는 비싸고 램 등 아래로 갈수록 비용은 더 저렴함

계층이 있고 캐싱 때문에 비용을 좀 더 효율적으로 쓸 수 있음

### 자원의 효율적 사용

메모리 계층 구조는 자주 접근하는 데이터는 빠른 메모리에, 덜 접근하는 데이터는 느린 메모리에 저장하여 자원을 효율적으로 사용

거의 접근하지 않은 데이터에 비싸고 빠른 메모리를 사용하지 않게 되어 자원을
낭비하지 않게 됨

흔히 볼 수 있는 `로딩 중`이라는 것은 이 내부에서 하드디스크 또는 인터넷에서 데이터를 읽어 RAM으로 전송하는 과정이 아직 끝나지 않았음을 의미

<br>

# 가상 메모리와 스와핑, 페이지 폴트 그리고 스레싱

가상 메모리(Virtual Memory)는 OS에서 사용되는 메모리 관리 기법의 하나

컴퓨터가 실제로 이용 가능한 메모리 자원(실제 주소, physical address)을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것

가상 주소는 MMU와 페이지 테이블(Page Table)에 의해 실제 주소로 변환됨

- 페이지: 가상 메모리를 사용하는 최소 크기 단위

- 프레임: 실제 디스크나 메모리를 사용하는 최소 크기 단위

## 페이지 테이블

가상 메모리는 가상 주소와 실제 주소가 매핑되어있는 페이지 테이블로 관리되며 이 때 속도 향상을 위해 캐싱 계층인 TLB를 사용

가상 주소에서 바로 페이지 테이블을 가는게 아니라 TLB에서 있는지를 확인하고 만약 없다면 페이지테이블로 가서 실제 주소를 가져옴

## 페이지 폴트와 스와핑

가상 메모리는 작은 메모리를 매우 큰 메모리로 보이게끔 하는 것이기 때문에 참조하려는 메모리 영역이 실제에는 없을 수도 있음

즉, 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우가 있으며 이 때 페이지 폴트가 발생

이 때 메모리의 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 **마치 메모리처럼** 불러와 쓰는 것을 스와핑이라고 함

## 페이지 폴트의 과정

1. 어떤 명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 만약 없다면 트랩이 발생되어 운영체제에 알림

2. 운영체제는 실제 디스크로부터 사용하지 않은 프레임을 찾음

3. 해당 프레임을 실제 메모리에 가져와서 페이지 교체 알고리즘을 기반으로 특정 페이지와 교체(이 때 스와핑이 일어남)

4. 페이지 테이블을 갱신시킨 후 해당 명령어를 다시 시작

## 스레싱

스레싱은 메모리의 페이지 폴트율이 높은 것을 의미 → 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생

페이지 폴트가 일어나면 CPU 이용률은 낮아지고 CPU 이용률이 낮아지게 되면 운영체제는 CPU의 가용성을 높이기 위해 더 많은 프로세스를 메모리에 올림 → 이러한 악순환이 반복되어 스레싱이 일어남

이를 하드웨어적으로 해결하는 방법은 메모리를 늘리거나 HDD를 사용한다면 HDD를
SSD로 바꾸는 방법

운영체제에서 해결하는 방법은 작업 세트와 PFF가 있음

### 작업 세트

작업 세트(Working Set)는 프로세스의 과거 사용 이력을 기반으로 많이 사용하는
페이지 집합을 만들어 한꺼번에 미리 메모리에 로드하는 것

### PFF

PFF(Page Fault Frequency)는 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만들고 상한선에 도달한다면 프레임을 늘리고 하한선에 도달한다면 프레임을 줄이는 방법

## 가상 메모리의 필요성

### 주기억장치의 효율적 관리(스와핑)

하드디스크를 주기억장치에 대한 캐시로 설정하여, 당장 사용하는 영역만 유지하고 쓰지 않는 데이터는 하드디스크로 옮긴 뒤, 필요할 때만 램에 데이터를 불러와 올리고 다시 사용하지 않으면 하드디스크로 내림으로써 램을 효과적으로 관리

### 메모리 관리의 단순화

각 프로세스마다 가상 메모리의 통일된 주소 공간을 배정할 수 있으므로 메모리 관리가 단순해짐

### 메모리 용량 및 안정성 보장

한정된 공간의 램이 아닌 거의 무한한 가상 메모리 공간을 배정함으로써 프로세스들끼리 메모리 침범이 일어날 여지를 크게 줄이게 됨

<br>

# 페이지 교체 알고리즘

스와핑이 일어날 때 페이지 교체 알고리즘(Page Replacement Algorithm)에 의해 페이지가 교체

## 오프라인 알고리즘

가장 좋은 알고리즘이라고 일컫는 알고리즘이며 이는 가장 먼 미래에 참조되는 페이지와 현재의 페이지를 바꾸는 알고리즘(Longest Forward Distance, LFD)

예를 들어 0, 1, 2, 3, 4, 2 가 들어온다고 가정하면 가장 미래에 참조되는 2와 스와핑하는 것

그러나 미래에 사용되는 프로세스를 알지 못하기 때문에 사용할 수 없는 알고리즘이지만 다른 알고리즘과의 성능 비교에 대한 상한선을 제공

### FIFO(First In First Out)

가장 먼저 온 페이지부터 교체하는 방법

### LRU(Least Recently Used)

최근에 사용되지 않은 페이지를 바꾸는 방법

즉, 참조가 오래된 페이지를 바꾸며 이를 위해서 각 페이지마다 최근 사용한 횟수를 나타내는 자료구조를 따로 만들어야 할 수도 있음

### NUR(Not Used recently)

LRU에서 발전한 알고리즘이자 NRU(Not Recently Used)라고도 불림

일명 clock 알고리즘

- 먼저 0과 1을 가진 비트를 두며 1은 최근에 참조되었고 0은 참조되지 않음을 의미

- 만약 한 바퀴 도는 동안 사용되지 않으면 0이 됨

- 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 페이지를 교체하고 해당 부분을 1로 바꿈

### LFU(Least Frequently Used)

가장 참조 횟수가 적은 페이지를 교체하는 알고리즘

<br>

# 프로세스와 스레드의 차이

## 프로세스(Process)

컴퓨터의 메모리에 올라와 실행되고 있는 프로그램, Task와 같은 의미로 쓰임

하나의 스레드로 이루어진 싱글스레드 프로세스, 여러개의 스레드로 이루어진 멀티스레드 프로세스로 나뉨

## 스레드(Thread)

프로세스 내 작업의 흐름

## 프로세스와 스레드의 차이

1. 프로세스는 코드, 데이터, 스택, 힙 메모리 영역을 기반으로 작업하는 반면 스레드는
   프로세스 내의 스택 메모리를 제외한 다른 메모리 영역을 프로세스 내의 다른 스레드들과
   공유 → 메모리적 이점이 있음

2. 프로세스는 다른 프로세스와 격리되어있기 때문에 서로 통신을 하기 위해서는 IPC를
   사용해야 하지만 스레드는 다른 스레드와 서로 격리되어있지 않으므로 그냥 통신할 수
   있음 → 프로세스보다 더 빠름

3. 프로세스는 한 프로세스에 문제가 생겨도 다른 프로세스에 영향을 끼치지 않지만 스레드는 격리가 되어있지 않아 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있음

4. 프로세스는 생성과 종료에 더 많은 시간이 걸리며 스레드는 더 적은 시간이 걸림

<br>

# 프로그램의 컴파일 과정

프로그램은 컴파일러가 컴파일 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행될 수 있는 파일이 된 것을 의미

## 1. 전처리

소스코드의 주석 제거, #include 등 헤더 파일을 병합하고 매크로를 치환

## 2. 컴파일러

오류 처리, 코드 최적화 작업을 하여 어셈블리어로 변환

## 3. 어셈블러

어셈블리어는 목적 코드(object code)로 변환

이 때 확장자는 운영체제마다 다른데 리눅스에서는 .o(가영.c라는 파일을 만들면 가영.o라는 파일이 만들어짐)

## 4. 링커

프로그램 내에 있는 라이브러리 함수 등과 결합해 실행 파일이 만들어짐(.exe, .out 등의 확장자)

<br>

# 프로세스의 메모리 구조

운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당

위에서부터 스택(Stack), 힙(Heap), 데이터 영역(BSS Segment, Data Segment), 코드 영역
(Code Segment)으로 나눠짐

스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당

- 스택: 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정되지만 함수가 함수를 호출 하는 등에 따라 런타임 시에도 크기가 변경 → 동적인 특징

- 힙: 힙은 동적할당할 때 사용되며 런타임 시 크기가 결정 → 동적인 특징

- 데이터 영역: BSS 영역과 Data 영역으로 나뉘고 정적 할당에 관한 부분을 담당 → 정적인 특징

- 코드 영역: 소스코드 들어감 → 정적인 특징

## 정적할당

컴파일 단계에서 메모리를 할당하는 것

BSS Segment와 Data Segment, Code/Text Segment로 나뉘어서 저장됨

**BSS Segment**는 전역변수, static, const로 선언되어있는 변수 중 0으로 초기화 또는 어떠한 값으로도 초기화되어있지 않은 변수들이 이 메모리 영역에 할당

**Data Segment**는 전역변수, static, const로 선언되어있는 변수 중 0이 아닌 값으로 초기화된
변수가 이 메모리 영역에 할당

**Code/Text Segment**는 프로그램의 코드가 들어감

## 동적할당

런타임 단계에서 메모리를 할당받는 것이며 Stack과 Heap으로 나눠짐

### Stack

Stack은 지역변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역

함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 Stack에 계속해서 저장

참고로 재귀함수가 호출될 때 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않음

### Heap

Heap은 동적으로 할당되는 변수들을 담으며 malloc(), free() 함수를 통해 관리할 수 있음

동적으로 관리되는 자료구조의 경우 Heap 영역을 사용(예를 들어 vector는 내부적으로 Heap 영역을 사용)

<br>

# PCB와 컨텍스트 스위칭

PCB(Process Control Block)는 운영체제에서 관리하는 프로세스에 대한 메타데이터를
저장한 데이터 블록

커널 스택에 저장되며 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고 프로세스가 종료되면 PCB는 제거됨

### (참고) 커널스택

가상 메모리는 사용자 공간과 커널 공간으로 구분

이 두가지의 공간 모두 스택 자료구조를 기반으로 관리되기 때문에 사용자 스택, 커널 스택이라고도 불리는데 커널 스택은 가상 메모리 주소의 윗부분을 말함(가장 처음 시작하는 주소값)

커널스택은 **커널 모드**에서만 접근할 수 있게 되어있으며 반대로 사용자스택은 유저모드에서만 접근 가능

### (참고) 메타데이터

데이터에 관한 구조화된 데이터이자 데이터를 설명하는 작은 데이터

대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 규칙에 따라 콘텐츠에 대해 부여되는 데이터

## PCB의 구조

중요한 것만 필기

- 프로세스 상태: 대기 중, 실행 중 등 프로세스의 상태

- 프로세스 번호(PID): 각 프로세스의 고유 식별 번호(프로세스 ID)

- 프로그램 카운터(PC): 이 프로세스에 대해 실행될 다음 명령의 주소에 대한 포인터

- 레지스터: 레지스터 관련 정보

- 메모리 제한: 프로세스의 메모리 관련 정보

- 열린 파일 정보: 프로세스를 위해 열린 파일 목록들

## 컨텍스트 스위칭(Context Switching)

PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 과정(프로세스 기준으로 설명, 스레드 또한 가능)

프로세스가 종료되면 발생하거나 인터럽트에 의해 발생

### 컨텍스트 스위칭의 비용

1. 유후시간의 발생: 컨텍스트 스위칭을 할 때마다 유후시간이 생겨서 CPU의 가용성이 떨어지는 비용이 발생

2. 캐시미스: 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시클리어 과정이 무조건 일어나고 이 때문에 캐시미스가 발생

### 스레드에서의 컨텍스트 스위칭

스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 비용이 더 적고 시간도 더 적게
걸린다는 장점이 있음

<br>

# 프로세스의 상태

(ready suspended와 blocked suspended와 blocked를 묶어서 waiting 상태라고 표현하기도 함)

## 생성 상태(create or new)

프로세스가 생성된 상태를 의미

fork() 또는 exec() 함수를 통해 프로세스가 생성된 상태이며 이 때 PCB가 할당

### fork( )

부모 프로세스의 주소 공간을 그대로 복사하며 새로운 자식 프로세스를 생성하는 함수

주소 공간만 복사할 뿐이지 부모 프로세스의 비동기 작업 등을 상속하지는 않음

### exec( )

exec()은 새롭게 프로세스를 생성하는 함수

## 대기 상태(ready)

처음 프로세스가 생성(create)된 이후 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 준비 큐(준비 순서열)에 들어가서 대기중인 상태

이는 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

## 대기 중단 상태(ready suspended)

준비 큐가 꽉찬 상태 즉, 메모리 부족으로 일시 중단된 상태

## 실행 상태(running)

CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태

이를 CPU burst가 일어났다고도 표현

## 중단 상태(blocked)

어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태

## 일시 중단 상태(blocked suspended)

대기 중단과 유사하며 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태

## 종료 상태(terminated or exit)

프로세스 실행이 완료되어 해당 프로세스에 대한 자원을 반납하며 PCB가 삭제되는 상태

종료는 자연스럽게 종료되는 것도 있지만 부모 프로세스가 자식 프로세스를 강제적으로 종료시켜 비자발적 종료(abort)로 종료되는 것도 있음

자식 프로세스에 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process.kill 등 여러 명령어로 프로세스를 종료시킬 때 발생

<br>

# 멀티프로세싱과 멀티스레딩

## 멀티프로세싱

여러 개의 **프로세스**, 즉 멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것

특정 프로세스 중 일부에 문제가 발생되더라도 다른 프로세스에 영향을 미치지 않으며 격리성과 신뢰성이 높은 강점이 있음

## 멀티스레딩

프로세스 내 작업을 멀티스레드로 처리하는 기법이며 스레드끼리 서로 자원을 공유하고 프로세스보다는 가볍기 때문에 효율성이 높은 장점이 있음

하지만 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있는 단점이 있음

브라우저는 멀티프로세스이자 멀티스레드 아키텍처를 가진 소프트웨어
