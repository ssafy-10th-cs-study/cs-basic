## 디자인 패턴의 종류

### 생성패턴

객체 생성 방법

ex) **싱글톤**, **팩토리**, 추상 팩토리, 빌더, 프로토타입 패턴 등

### 구조 패턴

객체, 클래스 등으로 큰 구조를 만들 때 유연하고 효율적으로 만드는 방법

ex) **프록시**, 어댑터, 브리지, 복합체, 데코레이터, 퍼사드, 플라이 웨이트패턴 등

### 행동 패턴

객체나 클래스 간의 알고리즘, 책임 할당에 관한 디자인 패턴

ex) **이터레이터**, **옵저버**, **전략**, 책임연쇄, 커맨드, 중재자, 메멘토, 상태, 템플릿메서드, 비지터 패턴 등

<br>

## 라이브러리와 프레임워크의 차이

## 라이브러리

공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것

폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유로움

## 프레임워크

공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것

폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격함

<br>

## 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

### 장점

- 인스턴스 생성에 많은 코스트가 드는 데이터베이스 연결 모듈에 많이 쓰이며 인스턴스 생성이 효율적임

### 단점

- 의존성이 높아지고 TDD(테스트 주도 개발)를 할 때 불편함

## 싱글톤 패턴을 구현하는 7가지 방법

(면접에서 구현까지는 잘 물어보지 않음)

1. 단순한 메서드 호출

싱글톤 패턴 생성 여부를 확인하고 싱글톤이 없으면 새로 만들고 있다면 만들어진 인스턴스 반환

- 원자성 결여 - 멀티스레드 환경에서는 싱글톤 인스턴스를 2개 이상 만들 수 있음

2. synchronized 키워드

인스턴스를 반환하기 전까지 격리 공간에 놓기 위해 symchronized 키워드로 잠금(lock)

최초로 접근한 스레드가 해당 메서드 호출시에 다른 스레드가 접근하지 못하도록 잠금을 걸어줌

- `getInstance()` 메서드를 호출할 때마다 잠금이 걸려 성능 저하

3. 정적 멤버

정적(static) 멤버나 블록은 런타임이 아니라 최초에 JVM이 클래스 로딩 때 모든 클래스들을 로드할 때 미리 인스턴스를 생성하는데 이를 이용한 방법

따라서 클래스 로딩과 동시에 싱글톤 인스턴스를 만들고 모듈들이 싱글톤 인스턴스를 요청할 때 그냥 만들어져 있는 인스턴스를 반환

- 불필요한 자원낭비라는 문제점 - 싱글톤 인스턴스가 필요없는 경우도 무도건 싱글톤 클래스를 호출해서
인스턴스를 만들어야 하기 때문

4. 정적 블록

정적 블록 사용

5. 정적 멤버와 Lazy Holder(중첩 클래스)

`singleInstanceHolder`라는 내부 클래스를 하나 더 만들어서 싱글톤 클래스가 최초에 로딩될 때 함께 초기화 되는 것이 아니라 `getInstance()`가 호출될 때 `singleInstanceHolder`` 클래스가 로딩되어 인스턴스를 생성
→ 필요할 때만 생성 가능

6. 이중 확인 잠금(DCL)

인스턴스 생성 여부를 싱글톤 패턴 잠금 전에 한 번, 객체를 생성하기 전에 한 번 체크하면 인스턴스가 존재하지 않을 때만 잠금을 걸 수 있음

**volatile**
```Java
private volatile Singleton instance;
private Singleton() {}
```
instance 변수에 volatile 키워드를 붙인 이유
- 메모리 구조는 메인 메모리 위에 CPU 캐시 메모리라고 불리는 L3, L2, L1이 있는데 자바는 스레드가 여러 개 열리면 변수를 메인 메모리(RAM)으로부터 가져오는 것이 아니라 캐시 메모리에서 각각의 캐시 메모리를 기반으로 가져오게 됨

→ 변수 값 불일치 문제(각각의 캐시 메모리에서 가져와서 변수명 같아도 공유가 안됨)

이 때 `volatile` 키워드를 추가하면 메인 메모리를 기반으로 저장하고 읽어오기 때문에 이 문제를 해결할 수 있음

7. enum

enum 인스턴스는 기본적으로 스레드세이프(thread safe)한 점이 보장되기 때문에 이를 통해 생성

→ 개발자가 따로 뭔가 할 필요 없음

**최고의 방법은?**

5번(가장 많이 쓰임), 7번(Effective Java를 쓴 Joshua Bloch가 추천)

<br>

## 팩토리 패턴

상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

- 상위 클래스에서는 객체 생성 방식에 대해 알 필요가 없어져 유연성을 갖게 됨

- 하위 클래스에서만 객체 생성 로직을 관리하기 때문에 유지보수성이 증가

예시로 생성 로직을 수정하고 싶으면 상위 클래스 건들지 않고 하위 클래스만 수정하면 됨

<br>

## 이터레이터 패턴

이터레이터(iterator)를 사용하여 컨테이너의 요소들에 접근하는 디자인 패턴

**컨테이너** 동일한 요소들을 담아놓는 집합을 말함(배열, 맵 등)

### 장점

각기 다른 자료구조들을 똑같은 인터페이스로 쉽게 순회할 수 있음

<br>

## DI와 DIP

의존성 주입(DI)이란 메인모듈이 ‘직접’ 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자(dependency injector)가 이 부분을 가로챔

→ 메인 모듈이 간접적으로 의존성을 주입하는 방식

이를 통해 메인 모듈과 하위 모듈간의 의존성을 조금 더 느슨하게 만들 수 있으며 모듈을 쉽게 교체 가능한 구조로 만듦

A가 B에 의존한다 = B가 변하면 A에 영향을 미치는 관계 = `A → B`

DI를 하게 되면 **의존관계역전원칙(Dependency Inversion Principle)**이 적용

- 상위 모듈은 하위 모듈에 의존해서는 안되고 둘 다 추상화에 의존해야 함
  
- 추상화는 세부사항에 의존해서는 안되고 세부 사항은 추상화에 따라 달라져야 함

### 의존성 주입 장점

- 외부에서 모듈을 생성하여 `dev.add(new BackendDeveloper())` 구조가 되기 때문에 모듈들을 쉽게 교체할 수 있는 구조가 됨
  
- 단위 테스팅과 마이그레이션(DB 이동, 데이터 이동 등 다른 운영 환경으로 이동하는 것)이 쉬워짐
  
- 애플리케이션 의존성 방향이 좀 더 일관되어 코드를 추론하기가 쉬워짐

### 의존성 주입 단점

- 결국에는 모듈이 더 생기게 되므로 복잡도가 증가

- 종속성 주입 자체가 컴파일을 할 때가 아닌 런타임 때 일어나기 때문에 컴파일을 할 때 종속성 주입에 관한 에러를 잡기가 어려워질 수 있음