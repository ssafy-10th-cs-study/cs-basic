## HTTP 헤더(Header)

**HTTP** 처음에는 서버와 브라우저간에 데이터를 주고 받기 위해 설계된 프로토콜

지금은 브라우저 뿐만 아니라 서버와 서버간의 통신할 때도 많이 이용

사용자가 HTTP 요청을 하면 헤더와 바디(JSON, HTML, XML 등 본문)로 나누어져서 컨텐츠 받아옴

**바디**는 본문이라고 할 수 있으며 서버에서 보내고자 하는 컨텐츠 본문인 JSON, html, image 등이 담김

**헤더**는 바디를 설명하는 정보를 포함해서 여러가지 정보가 담긴 정보 묶음

헤더는 콜론(:)으로 서로 구분되는 key - value 형태로 설정

HTTP 요청을 할 때 3가지의 헤더인 일반헤더, 요청헤더, 응답헤더가 자동으로 생성

서버에서 설정하는 헤더는 응답헤더, 클라이언트에서 설정한 헤더는 요청헤더

### 일반헤더(공통)

요청한 URL, 요청 메서드, 해당 자원을 요청할 때 해당 자원의 출처를 나타내는 URL을 노출시킬지 말지를 정하는 보안 정도가 설정되어있는 Referrer Policy 등이 들어감

### 요청헤더(클라이언트 → 서버)

클라이언트가 서버에 요청할 때 클라이언트가 설정하거나 또는 자동으로 설정되는 헤더

요청 헤더에는 메서드, 클라이언트의 OS, 브라우저 정보 등이 담김

### 응답헤더(서버 → 클라이언트)

서버가 클라이언트에게 응답을 보낼 때 설정하거나 또는 자동으로 설정되는 헤더

응답 헤더는 서버의 소프트웨어 정보 등이 담김

- 예를 들어 nginx를 프록시 서버로 두었다면 해당 정보가 표기됨(하지만 대부분의 서버는 일반적으로 해커가 서버에서 어떤 소프트웨어가 사용되고 있는지 알기 어렵게 하기 위해 서버 정보를 숨김)

HTTP 헤더 자체가 굉장히 유연하게 설계가 되어있어서 커스텀하게 만들 수 있지만 보통은 지정되어있는 key값에 value를 담아서 헤더를 설정

- 예를 들어 쿠키를 설정할 때 요청헤더에는 Cookie라는 key에, 응답헤더에는 Set-cookie라는 key에 쿠키를 담아 설정함

<br>

## HTTP/1.0

수명이 짧은 연결이라고 하며 HTTP 요청은 자체 요청에서 완료가 됨

각 HTTP 요청당 TCP 핸드셰이크가 발생되며 기본적으로 한 연결당 하나의 요청을 처리하도록 설계

한번 연결할 때마다 TCP연결을 계속해야 하니 RTT가 늘어나는 문제점이 있고 이를 해결하기 위해 HTTP/1.1이 나옴

**RTT(Round Trip Time)**

RTT(왕복 지연 시간)는 신호를 전송하고 해당 신호의 수신확인에 걸린 시간을 더한 값이자 어떤 메시지가 두 장치 사이를 왕복하는 데 걸린 시간

<br>

## HTTP/1.1

HTTP/1.1은 HTTP/1.0의 단점을 보완한 프로토콜이며 크게 3가지의 차이점이 있음

### 1. keep-alive default

매번 데이터를 요청할 때마다 TCP 연결을 하는게 아닌 한번 해놓고 계속해서 데이터를 받을 수 있게 만들었고 이는 keep-alive 옵션(TCP연결을 유지하는 것을 알려주는 헤더로 연결 유지 시간인 timeout과 최대 요청수 max를 정할 수 있음)을 기본 옵션으로 하면서 가능해짐

### 2. 호스트 헤더

HTTP/1.0은 서버가 하나의 호스트만 가진다고 가정하기 때문에 HTTP/1.0은 헤더에 호스트를 포함하지 않았고 이 때문에 HTTP/1.0은 하나의 IP에 하나의 호스트만 가질 수 있었음

그러나 사실 서버는 여러개의 호스트를 가질 수 있으며 이런 유연성을 위해 HTTP/1.1은 헤더에 특정 호스트를 포함할 수 있게 변경되었으며 항상 호스트를 포함해서 요청하도록 바뀜

### 3. 대역폭 최적화

HTTP/1.0의 경우 어떠한 파일을 다운로드 받다가 연결이 끊기면 다시 다운로드 받는 것은 불가능했지만 HTTP/1.1에서는 헤더를 추가해서 이를 다시 다운로드 받을 수 있게 바뀜

<br>

## 요청을 줄이기 위한 기술

HTTP/1.1로 발전했음에도 불구하고 서버가 요청할 때마다 RTT는 계속해서 증가하기 때문에 요청을 줄이기 위한 여러가지 기술들이 있고 HTTP 버전이 올라간 뒤에도 이러한 기술들을 같이 쓰곤 함

### 이미지 스프라이트

수많은 이미지를 하나의 이미지로 만들어 하나의 이미지만 다운받아놓고 이를 통해 수많은 이미지를 다운받는 듯한 효과를 내는 것

### 코드압축

코드를 압축해서 서빙

### 이미지 Base64 인코딩

이미지 파일을 64진법으로 이루어진 문자열로 인코딩해서 이미지 서버에 대한 HTTP 요청을 할 필요가 없이 만드는 것

하지만 Base64 인코딩을 할 경우 파일 크기가 37퍼센트 크기가 더 커지는 단점이 있음

### HTTP/1.1의 고질적인 문제 HOL

HOL과 무거운 헤더(Header)를 가지는 문제점이 있었고 이를 해결하지 못함

**HOL(Head Of Line Blocking)**

네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상

<br>

## HTTP/2와 HTTP/3의 차이

### HTTP/2

애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가

HTTP 1.0은 일반 텍스트 메시지를 전송하고 줄바꿈으로 데이터를 나눴다면

HTTP 2.0은 0과 1로 이루어진 바이너리 데이터로 변경되었고 더 작은 메시지가 프레임으로 캡슐화되어서 전송

### HTTP/3

HTTP/2는 여전히 TCP를 사용하기 때문에 초기 연결에 대한 RTT로 인한 지연 시간이라는 문제점이 있었고 이를 해결한 버전

QUIC(Quick UDP Internet Connections)이라는 계층 위에서 돌아가며, TCP 기반이 아닌 UDP 기반이고 HTTP/2의 장점이었던 멀티플렉싱 등을 가지고 있으며 초기 연결 설정 시 지연 시간 감소라는 대표적 특성이 있음

또한 HTTP/2의 경우 3 - RTT가 필요했다면 QUIC은 1 - RTT만 필요하다는 장점이 있음

→ HTTP/2의 경우 클라이언트와 서버간의 연결을 맺어 세션을 만드는데 필요한 핸드셰이크, 암호화 통신을 구축하기 위한 TLS 핸드셰이크가 각각 필요했음

그러나 HTTP/3는 TLS로 암호화 통신을 구축할 때의 단 한번의 핸드셰이크를 활용해 클라이언트와 서버간의 연결, 암호화 통신 모두 다 구축

이를 통해 1 - RTT만에 모든 연결을 성립할 수 있음

또한 전송된 패킷이 손실되었다면 수신측에서 에러를 검출하고 수정하는 방식

열악한 네트워크 환경에서도 낮은 패킷 손실률을 자랑하는 순방향 오류 수정 메커니즘(FEC, Forward Error Correction)이라는 특징

<br>

## 웹브라우저의 캐시 #1. 로컬 스토리지의 개념

웹 스토리지 객체로 브라우저 내에 `{ key : value }` 형태로 오리진에 종속되어 저장되는 데이터(오리진이 같은 브라우저 내에서 공유)

- 하나의 키에 오로지 하나의 값만 저장

- 데이터는 사용자가 브라우저에서 수동으로 삭제하지 않는 한 평생 동안 로컬 저장소에 저장되며 만료 날짜가 없음(사용자가 창이나 탭을 닫거나 컴퓨터를 종료해도 만료되지 않음)

- 최대 저장용량은 5MB

- 보통 사용자의 행위를 기억할 때, 로그인을 유지하기 위한 값 등으로 사용되며 로컬 스토리지 데이터는 자동으로 서버로 전송되지 않음(쿠키는 자동 전송됨)

**사용법**

- 설정 `localStorage.setItem(key, value);`

- key에 해당하는 value 가져오기 `localStorage.getItem(key);`

- 제거 `localStorage.removeItem(key);`

- 전체 제거 `localStorage.clear();`

<br>

## 웹브라우저의 캐시 #2. 로컬 스토리지와 오리진

<br>

## 웹브라우저의 캐시 #3. 로컬 스토리지를 활용사례: 캐싱

<br>

## 웹브라우저의 캐시 #4. 세션 스토리지

로컬 스토리지와 매우 유사하며 웹 스토리지 객체로 브라우저 내에 `{ key : value }` 형태로 오리진에 종속되어 저장되는 데이터(오리진이 같은 브라우저 내에서 공유)

- 하나의 키에 오로지 하나의 값만 저장

- 최대 저장용량은 5MB

- 사용자가 브라우저에서 탭을 닫으면 데이터는 만료됨

**사용법**

- 설정 `sessionStorage.setItem(key, value);`

- 탐색 `sessionStorage.getItem(key);`

- 제거 `sessionStorage.removeItem(key);`

- 전체 제거 `sessionStorage.clear();`

보통은 세션스토리지보다는 로컬스토리지를 많이 씀

<br>

## 웹브라우저의 캐시 #5. 쿠키(Cookie)

쿠키는 브라우저에 저장된 데이터 조각

클라이언트에서 먼저 설정할 수도 있고 서버에서 먼저 설정할 수 있으나 보통은 서버에서 먼저 설정해서 쿠키를 만드는게 일반적

서버에서 응답 헤더로 `Set-Cookie`로 설정해서 쿠키를 보내면 그 때부터 클라이언트에서 요청 헤더 Cookie에 설정되어 자동으로 서버에 전달되게 되고 브라우저에도 저장

(HTTP 헤더를 통해 클라이언트 또는 서버가 HTTP 요청 또는 응답할 때 추가 정보를 전달할 수 있음)

### 클라이언트에서도 설정가능한 쿠키

클라이언트에서 자바스크립트 `document.cookie`를 통해 쿠키를 설정할 수 있고 보낼 때도 `Header-Cookie`에 값을 정해서 보낼 수 있지만 이를 권장하지는 않음

→ 쿠키에 대한 제어권을 클라이언트에게 두게 되는데 쿠키에는 보통 민감한 정보들이 담길 수도 있기 때문에 이 제어권에 관한 것을 클라이언트가 아닌 서버가 두게 만들어야 함

### 세션 쿠키

Expires 또는 Max-Age 속성을 지정하지 않은 것을 말하며 브라우저가 종료되면 쿠키도 사라짐

### 영구 쿠키

Expires 또는 Max-Age 속성을 지정해서 특정 날짜 또는 일정 기간이 지나면 삭제되게 만든 쿠키, 브라우저를 닫을 때 만료되지 않음

<br>

## 웹브라우저의 캐시 #6. 로컬 스토리지, 세션 스토리지, 쿠키의 공통점과 차이점

### 공통점

1. 브라우저에 캐싱을 함으로써 서버에 대한 요청을 줄여 서버부하를 방지할 수 있음

2. 캐싱으로 인해 다운로드 하는 컨텐츠가 줄어들어 웹사이트의 컨텐츠를 더 빨리 다운로드가 가능

3. 사이트 기본 설정 커스터마이징(색상, 글꼴 크기 등)을 저장하거나 로그인 상태를 유지할 때 사용될 수 있음
