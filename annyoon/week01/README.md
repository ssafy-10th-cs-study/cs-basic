*JSON(JavaScript Object Notation)*

면접에서 JSON이 뭔가요? 라는 질문

**Javascript 객체 문법** 으로 구조화된 데이터 교환 형식

<br>

이미 존재하는 키 중복으로 선언하면 마지막에 선언한 값이 살아남음

JSON 파일을 기반으로 JS에서 어떤 로직을 구축할 때 JS Object로 변환해줘야함

이 때 쓰이는 것이 `JSON.parse()`

파이썬에서는 `JSON.loads()`라는 함수로 딕셔너리 타입으로 변환해서 씀

JSON이라는 파일은 그냥 못쓰고 언어마다 다르게 변환해서 씀

`->` JSON은 여러 언어, 플랫폼에 대해서 **독립적** 이다

언어가 업데이트된다고 JSON도 업데이트해야 하는 것은 아님(독립적)

객체는 다른 타입을 갖고 있어도 되지만 타입을 맞춰주는 것이 일반적임

JSON 타입은 JS Object와 유사하지만 undefined, 메서드 등은 포함할 수 없음

*직렬화*

외부 시스템에서도 사용할 수 있도록 바이트 형태로 데이터를 변환하는 기술 `<->` 역직렬화는 그 반대를 의미

- `JSON.parse()`로 JS(내부)에서 쓸 수 있도록 역직렬화
- `JSON.stringify()`로 파이썬(외부)에서 쓸 수 있도록 직렬화

*JSON의 활용*

프로그래밍 언어와 프레임워크 등에 독립적이므로 서로 다른 시스템간에 데이터를 교환하기 좋음

주로 API의 반환 형태, 시스템을 구성하는 설정파일에 활용됨

<br>

---

<br>

*XML(Extensible Markup Language)*

마크업 형태를 쓰는 데이터 교환 형식

마크업 형태 `->` 태그 등을 이용하여 문서나 데이터 구조를 나타내는 방법으로 `<name></name>` 처럼 태그로 감싸져 있는 형태

*XML 구성*

1. 프롤로그 - 버전, 인코딩
2. 루트 요소(하나만 존재)
3. 하위 요소들

면접에서 많이 나오는 질문 `->` *HTML과 XML의 비교*

1. HTML에서는 미리 정의된 태그가 있음 `<->` XML에서는 사용자 정의 태그를 만들 수 있음
2. HTML은 데이터를 **표시**하는 용도 `<->` XML은 데이터를 **저장 및 전송**하는 용도
3. HTML은 대소문자 구분하지 않음 `<->` XML은 구분함

*JSON과 XML의 비교*

닫힌 태그가 계속 들어가기 때문에 XML이 JSON보다 무겁고 JS Object로 변환하기 위해 더 많은 노력 필요

`->` JSON은 내장 모듈을 사용할 수 있는데 XML은 외부 라이브러리를 사용하거나 직접 구현이 필요하기 때문

*XML의 활용*

JSON과 비슷하게 여러 언어에서 **독립적**이다

대표적으로 `sitemap.xml`에 쓰이는데 이것은 서비스 내의 모든 페이지들을 리스트업한 데이터임

왜 필요한가 `->` 사이트가 매우 크거나 서로 링크가 종속적으로 연결되지 않은 경우

크롤링봇이 이를 누락하는 것을 방지하고 모든 페이지들을 크롤링(해서 DB에 저장)할 수 있도록 해줌

<br>

---

<br>


*API(Application Programming Interface)*

둘 이상의 컴퓨터 프로그램이 서로 통신하는 방법이자 컴퓨터 사이에 있는 **중계 계층**을 의미

ex) 프로토콜, 메서드, 데이터 타입 등이 정의된 중계 계층

*API에 정의되어 있는 것*
- HTTP, HTTPS 중 어떤 프로토콜로 통신할 것인지 `->` 프로토콜
- GET으로 받을건지 POST로 받을건지 등 HTTP의 여러 메서드 정의 `->` 메서드
- JSON, XML 등 어떤 데이터 교환 형식 사용할 것인지 `->` 데이터 타입

*인터페이스*

서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면

내부 서버가 어떻게 구현되어있는지 몰라도 인터페이스를 통해 통신 등이 가능

*API의 장점*
1. 제공자가 서비스의 중요한 부분을 드러내지 않아도 된다
2. 사용자는 해당 서비스가 어떻게 구현되는지 알 필요없이 필요한 정보만 받을 수 있다
3. OPEN API의 경우 앱 개발 프로세스를 단순화시키고 시간과 비용 절약할 수 있다 (네이버 로그인 API 사용하면 다 구현 안해도 됨)
4. 내부 프로세스가 수정되었을 때 API는 수정되지 않게 만들 수 있다 `->` 업데이트 빈도수 줄일 수 있음
5. 제공자는 데이터를 한 곳에 모을 수 있다 (어떤 이벤트 집계하려고 할 때 해당 이벤트 발생하면 해당 API 호출하게 만들기)

*API의 종류*
- **private** 내부적으로 사용되며 주로 해시키를 하드코딩해놓고 이를 기반으로 비밀스럽게 서버와 서버간 통신
- **public** 모든 사람이 사용할 수 있으며 많은 트래픽을 방지하기 위해 하루 요청 수의 제한, 계정당 제한 등으로 관리

<br>

---

<br>


*가상머신(클라우드의 기반 기술)*

**전통적인 배포 방식**

물리적인 컴퓨터 한 대에 하나의 OS를 깔고 여러가지 프로그램 설치하는 방식

계정을 나눠서 여러 사용자가 이용할 수 있긴 하지만 어떤 프로그램을 설치했을 때 다른 앱에 영향을 미침(서로 간섭할 수 있고 독립적이지 못함)

**가상화 배포방식**

가상머신을 기반으로 배포하는데 가상 머신이란 컴퓨터의 하드웨어를 소프트웨어적으로 구현한 것

계정을 나누는 것이 아니라 한 대의 컴퓨터로 여러 OS를 구동할 수 있음

CPU, RAM을 물리적으로 바꾸는 것이 아니라 설정만으로 이를 수행할 수 있음

`->` 클라우드는 이러한 가상화 기술로 한 대의 하드웨어로 여러 사용자들에게 독립적으로 클라우드 서비스를 할 수 있음

OS는 공유가 안되기 떄문에 가상머신에 일일히 OS를 설치해야함

*클라우드 서비스*

**오프프레미스**

내가 아닌 다른 회사의 공급자가 호스팅하고 인터넷을 통해 사용자에게 제공되는 인프라, 플랫폼 또는 소프트웨어

`->` 자체 인프라나 하드웨어 설치 없이도 애플리케이션과 리소스 싸고 쉽게 이용 가능

**온프레미스**

기업이나 개인이 자체 시설에서 보유하고 직접 유지 관리하는 프라이빗 데이터 센터(IDC)

`->` 네트워크 선, 서버, 데이터베이스까지 직접 설치