## IaaS(‌Infrastructure-as-a-Service)

단지 인프라만 제공

`node.js`, `MongoDB` 등을 개발자가 직접 설치해야함

빈 방을 제공하는 느낌

<br>

## PaaS(Platform-as-a-Service)

플랫폼 제공

`node.js`, `MongoDB` 등 설치되어 있고 그저 클릭을 통해서 서비스 이용 가능

모니터링, CI/CD 제공

빌트인 방 같은 느낌

<br>

## SaaS(Software-as-a-Service)

완전한 서비스(만들어져있는 서비스)

<br>

### IaaS와 PaaS 비교

- IaaS → 유연하며 플랫폼에 종속되지 않음 / 이식성 높음 / 운영비 효율 낮음

- PaaS → 유연하지 않고 플랫폼에 종속됨 / 이식성 낮음 / 운영비 효율 좋음

<br>

## 컨테이너

애플리케이션이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 코드와 모든 종속성을 패키징하는 소프트웨어의 표준 단위

가상 머신(OS 일일이 다 깔았음)에서 더 발전된 형식이 컨테이너 배포 방식

OS를 공유하기 때문에 빠르고 경량화되어있으며 격리성도 훌륭함

→ OS에 문제가 생기면 다른 앱에도 영향 미칠 수 있음

<br>

## 도커

컨테이너에 필요한 기능을 거의 모두 제공하는 플랫폼

→ 이식성, 유연성, 운영 효율성 모두 갖춤

애플리케이션 구동에 필요한 환경설정 관련 절차를 도커파일에 작성하고 그 후 빌드하면 도커 이미지가 생성

도커 이미지를 실행시키면 도커 컨테이너가 만들어짐

그 후 도커 컨테이너에 설정된 프로그램, 데이터 등이 실제 컴퓨팅 자원 위에서 돌아가게 됨

<br>

## CI/CD

개발자가 코드를 짠 후 → 지속적으로 코드를 합치고 코드를 배포하는 일

- 왜 필요한가? 여러 명의 개발자가 동시에 개발을 할 때 생기는 문제들 해결

개발 이후에 생산성을 높이기 위해 코드의 검사와 배포를 자동화시켜서 시간을 줄임

**continuous integration** 빌드 테스트 머지

**continuous delivery** 최종 산출물 저장하는 공간에 저장시킴

**continuous deployment** 실제 사용자들에게 배포

- 장점 → 코드 배포까지 더 체계적으로 만들어주고 테스트가 강제됨

### 빌드

webpack → 여러 모듈들을 정적 자산으로 바꿔줌(빌드)

(ex. 뷰 등 웹브라우저에서 사용할 수 없는 확장자로 이루어진 모듈들을 `HTML / CSS / Javascript` 등으로 바꿔줘서 사용 가능)

여러 소스코드와 리소스를 컴파일해서 실행할 수 있는 프로그램으로 만드는 과정

### 테스트

- 모듈 통합할 때 통합 테스트

- 사용자가 서비스 사용하는 상황 가정해서 테스트하는 엔드투엔드 테스트

- 함수 등 작은 단위를 테스팅하는 단위 테스트

- 보안 테스트(공격자들이 공격할 때 막는거)

### 머지

요즘 git 사용

충돌 최소화하는 것이 중요 → 작은 이슈 단위로 나눠서 머지

### 배포

사용자를 위한 서비스 + 내부적으로 QA 엔지니어나 관리자 페이지를 위한 배포

데이터웨어하우스로부터 데이터 가공해서 백엔드 개발자를 위한 배포

<br>

## 클래스

객체를 만들어 내기 위한 틀이며 만들어 내기 위한 틀이며 만들어낼 객체의 속성과 메서드의 집합을 담아놓은 것

<br>

## 객체

객체란 클래스로부터 만들어지는 실체, 클래스로 선언된 변수

```java
Person b;
```

<br>

## 인스턴스

객체가 메모리에 할당이 된 상태이며 런타임에 구동되는 객체를 말함

객체와 같은 의미로 쓰이기도 함

(aws의 클라우드의 가상서버라는 말로도 쓰임)

```java
b = new Person("이름", 1, 1000);
```

<br>

## static

클래스의 인스턴스가 아닌 클래스에 속하며 클래스의 변수, 메서드 등을 공유하는데 사용됨

이를 통해 해당 클래스로 만들어지는 객체 사이에서 중복되는 메서드, 속성을 효율적으로 정의할 때 쓰임

**장점**

단순히 전역변수가 아니라 클래스 내의 `static` 키워드로 선언하여

이 클래스의 객체들끼리 사용되는 메서드 또는 속성이다라는 것을 나타내주는 명시성

**단점**

선언과 동시에 미리 `heap` 영역이 아닌 `method area` 메모리 영역에 할당이 됨

프로그램이 종료될때까지 `GC`에 의해 메모리가 회수되지 않기 떄문에 만약 클래스가 객체로 쓰이지 않는다면 메모리 낭비를 불러올 수 있음

<br>

## 오버로딩

이름이 같아도 매개변수 개수, 타입, 순서를 다르게 해서 같은 이름으로도 여러개의 함수를 정의할 수 있는 것

→ 프로그램의 유연성을 높이고 결과적으로 코드를 깔끔하게 하는 효과가 있으며 같은 클래스 내에서 사용

<br>

## 오버라이딩

상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하는 것

상속 관계 클래스에서 사용되며(클래스끼리) `static`, `final`로 선언한 메서드는 오버라이딩이 불가능

<br>

## 추상화

복잡한 데이터, 구조, 시스템 등으로부터 핵심만을 가려내 덜자세하게 만드는 것

또는 세부사항, 절차 등을 감추고 인터페이스 등을 만드는 것으로 복잡도를 낮추는 방법

### 데이터 추상화

공통점은 모으고 차이점은 버림

ex. 고양이 강아지 원숭이 → 공통적인 특징을 묶어 동물이라는 카테고리로 카테고리화

### 프로세스 추상화

어떤 내부 프로세스를 숨기는 것

ex. 데이터베이스가 어떻게 데이터를 저장하는지 모르지만 단순하게 `insert`, `upsert`등의 쿼리로 데이터를 저장할 수 있음

(내부 프로세스와는 상관없이 *쿼리*를 통해 접근할 수 있음)